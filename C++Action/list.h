//==========================================================================
//
// リスト構造ヘッダー[list.h]
// Author：相馬靜雅
//
//==========================================================================
#ifndef _LIST_H_
#define _LIST_H_	// 二重インクルード防止

//==========================================================================
// リスト構造クラスの定義
//==========================================================================
template<class T> class CList
{
public:

	CList();			// コンストラクタ
	~CList();			// デストラクタ

	void PushBack(const T &data);	// データを格納

private:
	static T *m_pTop;	// 先頭のオブジェクトへのポインタ
	static T *m_pCur;	// 最後尾のオブジェクトへのポインタ
	T *m_pPrev;	// 前のオブジェクトへのポインタ
	T *m_pNext;	// 次のオブジェクトへのポインタ
	static int m_nNumAll;	// オブジェクトの総数
};

//==========================================================================
// コンストラクタ
//==========================================================================
template<class T> CList<T>::CList()
{
	// 値のクリア
	m_pPrev = NULL;
	m_pNext = NULL;
}

//==========================================================================
// デストラクタ
//==========================================================================
template<class T> CList<T>::~CList()
{
}

//==========================================================================
// データを格納
//==========================================================================
template<class T> void CList<T>::PushBack(const T &data)
{

	if (m_pCur != NULL)
	{// 最後尾が存在していたら

		m_pCur->m_pNext = data;	// 最後尾の次に自分自身を代入
		m_pCur = data;				// 最後尾を自分自身に更新
		m_pCur->m_pPrev = pObjCur;	// 最後尾の前に過去の最後尾を代入
	}
	else
	{// 最後尾が無かったら
		m_pCur = data;	// 最後尾を自分自身に更新
	}

	if (m_pTop == NULL)
	{// 先頭に何もなかったら
		m_pTop = data;	// 先頭に自分自身のポインタを渡す
	}

	// データを先頭に格納
	m_aData[m_nNumAll] = data;
	m_nNumAll++;
}


#endif